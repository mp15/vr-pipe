
=head1 NAME

VRPipe::Steps::vcf_apply_vqslod_cutoff - a step

=head1 DESCRIPTION

Runs vcf-annotate to filter VCFs for a minimum VQSLOD score based on  tranches
files generated by GATK VQSR. Other filters will be removed,  but could be
reapplied with the post_apply_vqslod_vcftools option.

=head1 AUTHOR

Shane McCarthy <sm15@sanger.ac.uk>.

=head1 COPYRIGHT AND LICENSE

Copyright (c) 2011-2012 Genome Research Limited.

This file is part of VRPipe.

VRPipe is free software: you can redistribute it and/or modify it under the
terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program. If not, see L<http://www.gnu.org/licenses/>.

=cut

use VRPipe::Base;

class VRPipe::Steps::vcf_apply_vqslod_cutoff with VRPipe::StepRole {
    use VRPipe::Parser;
    use VRPipe::Parser::tranches;
    
    method options_definition {
        return {
            vcf_annotate_exe           => VRPipe::StepOption->create(description => 'path to vcf-annotate executable',                                                                                                              optional => 1, default_value => 'vcf-annotate'),
            snp_ts_filter_level        => VRPipe::StepOption->create(description => 'Truth-sensitivity cutoff for SNPs',                                                                                                            optional => 1, default_value => 99.85),
            indel_ts_filter_level      => VRPipe::StepOption->create(description => 'Truth-sensitivity cutoff for Indels',                                                                                                          optional => 1, default_value => 97.0),
            post_apply_vqslod_vcftools => VRPipe::StepOption->create(description => 'after vcf-annotate, option to pipe output vcf through a vcftools command, e.g. "vcf-annotate --fill-ICF" to fill AC, AN, and ICF annotations', optional => 1),
        };
    }
    
    method inputs_definition {
        return {
            vcf_files           => VRPipe::StepIODefinition->create(type => 'vcf', max_files => -1, description => 'vcf files to filter for minimum VQSLOD score'),
            snp_tranches_file   => VRPipe::StepIODefinition->create(type => 'txt', min_files => 0,  max_files   => 1, description => 'vcf files to concat'),
            indel_tranches_file => VRPipe::StepIODefinition->create(type => 'txt', min_files => 0,  max_files   => 1, description => 'vcf files to concat'),
        };
    }
    
    method body_sub {
        return sub {
            my $self                  = shift;
            my $options               = $self->options;
            my $vcf_annotate_exe      = $options->{vcf_annotate_exe};
            my $snp_ts_filter_level   = $options->{snp_ts_filter_level};
            my $indel_ts_filter_level = $options->{indel_ts_filter_level};
            my $post_filter           = $options->{post_apply_vqslod_vcftools};
            my $filter                = $post_filter ? " | $post_filter" : '';
            
            my $snp_tranches   = $self->inputs->{snp_tranches_file}[0];
            my $indel_tranches = $self->inputs->{indel_tranches_file}[0];
            unless ($snp_tranches || $indel_tranches) {
                $self->throw("At least one of 'snp_tranches_file' or 'indel_tranches_file' must be an input to this step.");
            }
            
            my %args;
            $args{snp_ts}         = $snp_ts_filter_level   if ($snp_ts_filter_level);
            $args{snp_ts}         = $indel_ts_filter_level if ($indel_ts_filter_level);
            $args{snp_tranches}   = $snp_tranches->path    if ($snp_tranches);
            $args{indel_tranches} = $indel_tranches->path  if ($indel_tranches);
            
            my $vqslod_filter_path = $self->output_file(basename => "vqslod.filter", type => 'txt', temporary => 1)->path;
            $self->write_vqslod_filter_file($vqslod_filter_path, %args);
            
            my $req = $self->new_requirements(memory => 500, time => 1);
            foreach my $vcf (@{ $self->inputs->{vcf_files} }) {
                my $vcf_path = $vcf->path;
                my $basename = $vcf->basename;
                my $cat      = $basename =~ /\.gz$/ ? 'zcat' : 'cat';
                $basename =~ s/\.vcf(.gz)?$/.vqsr.vcf.gz/;
                my $vqsr_vcf      = $self->output_file(output_key => 'vqsr_vcf_files', basename => $basename, type => 'vcf', metadata => $vcf->metadata);
                my $vqsr_vcf_path = $vqsr_vcf->path;
                my $this_cmd      = qq[$cat $vcf_path | $vcf_annotate_exe -r FILTER -f $vqslod_filter_path$filter | bgzip -c > $vqsr_vcf_path];
                $self->dispatch_wrapped_cmd('VRPipe::Steps::vcf_apply_vqslod_cutoff', 'apply_vqslod_and_check', [$this_cmd, $req, { output_files => [$vqsr_vcf] }]);
            }
        };
    }
    
    method outputs_definition {
        return { vqsr_vcf_files => VRPipe::StepIODefinition->create(type => 'vcf', max_files => -1, description => 'VCF files filtered for a minimum VQSLOD score') };
    }
    
    method post_process_sub {
        return sub { return 1; };
    }
    
    method description {
        return "Runs vcf-annotate to filter a VCFs for a minimum VQSLOD score based on tranches files generated by GATK VQSR";
    }
    
    method max_simultaneous {
        return 0;            # meaning unlimited
    }
    
    method apply_vqslod_and_check (ClassName|Object $self: Str $cmd_line) {
        my ($in_path, $out_path) = $cmd_line =~ /^\S+ (\S+) .+ bgzip -c > (\S+)$/;
        $in_path  || $self->throw("cmd_line [$cmd_line] was not constructed as expected");
        $out_path || $self->throw("cmd_line [$cmd_line] was not constructed as expected");
        
        my $in_file  = VRPipe::File->get(path => $in_path);
        my $out_file = VRPipe::File->get(path => $out_path);
        
        $in_file->disconnect;
        system($cmd_line) && $self->throw("failed to run [$cmd_line]");
        
        $out_file->update_stats_from_disc(retries => 3);
        my $in_records  = $in_file->num_records;
        my $out_records = $out_file->num_records;
        
        if ($out_records < $in_records) {
            $out_file->unlink;
            $self->throw("cmd [$cmd_line] failed because there were less records in the output file ($out_records) than the input file ($in_records)");
        }
        else {
            return 1;
        }
    }
    
    method write_vqslod_filter_file (ClassName|Object $self: Str|File $filter!, Num :$snp_ts = 99.85, Num :$indel_ts = 97.0, Str|File :$snp_tranches?, Str|File :$indel_tranches?) {
        unless (ref($filter) && ref($filter) eq 'VRPipe::File') {
            $filter = VRPipe::File->create(path => file($filter));
        }
        unless ($snp_tranches || $indel_tranches) {
            $self->throw("At least one of 'snp_tranches_file' or 'indel_tranches_file' must be an input to this step.");
        }
        
        # Find the MinVQSLOD score for the truth sensitivity cutoffs
        my ($snp_vqslod, $indel_vqslod) = (0, 0);
        if ($snp_tranches) {
            my $snp_pars = VRPipe::Parser->create('tranches', { file => $snp_tranches });
            my $snp_parsed_record = $snp_pars->parsed_record();
            while ($snp_pars->next_record()) {
                next unless $snp_parsed_record->{targetTruthSensitivity} < $snp_ts;
                $snp_vqslod = $snp_vqslod > $snp_parsed_record->{minVQSLod} ? $snp_vqslod : $snp_parsed_record->{minVQSLod};
            }
            $self->throw("SNPs VQSLOD cutoff corresponding to $snp_ts not found in tranches file $snp_tranches") unless ($snp_vqslod);
        }
        if ($indel_tranches) {
            my $indel_pars = VRPipe::Parser->create('tranches', { file => $indel_tranches });
            my $indel_parsed_record = $indel_pars->parsed_record();
            while ($indel_pars->next_record()) {
                next unless $indel_parsed_record->{targetTruthSensitivity} < $indel_ts;
                $indel_vqslod = $indel_vqslod > $indel_parsed_record->{minVQSLod} ? $indel_vqslod : $indel_parsed_record->{minVQSLod};
            }
            $self->throw("INDELs VQSLOD cutoff corresponding to $indel_ts not found in tranches file $indel_tranches") unless $indel_vqslod;
        }
        
        # Build the filter description for the header
        my @cutoffs = ();
        my $fh      = $filter->openw;
        if ($snp_ts && $snp_vqslod) {
            push @cutoffs, "SNPs:$snp_vqslod, truth sensitivity $snp_ts";
        }
        if ($indel_ts && $indel_vqslod) {
            push @cutoffs, "Indels:$indel_vqslod, truth sensitivity $indel_ts";
        }
        my $desc = 'Minimum VQSLOD score (INFO/VQSLOD) [' . join('; ', @cutoffs) . ']';
        
        # Make the filter file
        if ($snp_ts && $snp_vqslod) {
            print $fh qq[
{
    tag  => 'INFO/VQSLOD',
    name => 'MinVQSLOD',
    apply_to => 'SNPs',
    desc => '$desc',
    test => sub { return \$MATCH < $snp_vqslod ? \$FAIL : \$PASS },
},
];
        }
        if ($indel_ts && $indel_vqslod) {
            print $fh qq[
{
    tag  => 'INFO/VQSLOD',
    name => 'MinVQSLOD',
    apply_to => 'indels',
    desc => '$desc',
    test => sub { return \$MATCH < $indel_vqslod ? \$FAIL : \$PASS },
},
];
        }
        $filter->close;
        
        $filter->update_stats_from_disc(retries => 3);
        $self->throw("Nothing written to vqslod filter file " . $filter->path) unless ($filter->lines);
    }
}

1;
